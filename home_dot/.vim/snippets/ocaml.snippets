snippet gcdlcm
abbr gcdlcm
	let gcd m n =
		let rec doit x y =
			if y <= 0 then x else doit y (x mod y) in
		doit (max m n) (min m n)

	let lcm m n = m * n / (gcd m n)
	${0}
snippet iota
abbr iota
	let iota ?(start=0) ?(step=1) cnt =
		let rec doit i acc =
			if i <= 0 then acc
			else doit (i - 1) (start + step*(i - 1) :: acc) in
		doit cnt []
	${0}
snippet lowerbound
abbr lower_bound
	let lower_bound a first last v =
		let rec doit len first =
			if len = 0 then first
			else
				let half = len / 2 in
				let mid = first + half in
				if a.(mid) < v then doit (len - half - 1) (mid + 1)
				else doit half first in
		doit (last - first + 1) first
	${0}
snippet measure
abbr measure
	let measure f = let t = Sys.time () in f (); Sys.time () -. t
	${0}
snippet nthroot
abbr nth_root
	let nth_root x n =
		let fx = float_of_int x in
		let fn = float_of_int n in
		if x < 0 && n mod 2 = 1 then (-. exp (log (-. fx) /. fn))
		else exp (log fx /. fn)
	${0}
snippet piutils
abbr pi
	let pi = 4. *. atan 1.

	let degree_to_radian d = pi *. d /. 180.
	${0}
snippet split
abbr split_on_char
	let split_on_char sep s =
		let open String in
		let r = ref [] in
		let j = ref (length s) in
		for i = length s - 1 downto 0 do
			if get s i = sep then begin
				r := sub s (i + 1) (!j - i - 1) :: !r;
				j := i
			end
		done;
		sub s 0 !j :: !r
	${0}
snippet myary
abbr my Array module
	module Array = struct
		include Array

		let rev_iter f a =
			let rec doit i =
				if i < 0 then ()
				else (f (Array.get a i); doit (i - 1)) in
			doit (Array.length a - 1)

		let rev_iteri f a =
			let rec doit i =
				if i < 0 then ()
				else (f i (Array.get a i); doit (i - 1)) in
			doit (Array.length a - 1)

	end
	${0}
snippet mystr
abbr my string module
	module String = struct
		include String

		let split_on_char sep s =
			let open String in
			let r = ref [] in
			let j = ref (length s) in
			for i = length s - 1 downto 0 do
				if get s i = sep then begin
					r := sub s (i + 1) (!j - i - 1) :: !r;
					j := i
				end
			done;
			sub s 0 !j :: !r

		let to_int_list str =
			Str.split (Str.regexp " ") str |> List.map int_of_string

		let to_float_list str =
			Str.split (Str.regexp " ") str |> List.map float_of_string

		let to_string_list str = Str.split (Str.regexp " ") str

		let to_list str =
			let rec doit i acc =
				if i < 0 then acc
				else doit (i - 1) (String.get str i :: acc) in
			doit (String.length str - 1) []

		let fold_left f init str =
			let n = String.length str - 1 in
			let rec doit i acc =
				if i > n then acc
				else doit (i + 1) (f acc str.[i]) in
			doit 0 init

	end
	${0}
snippet mylst
abbr my List module
	module List = struct
		include List

		let take n lst =
			let rec doit n lst acc =
				if n <= 0 then List.rev acc
				else
					match lst with
					| [] -> List.rev acc
					| hd :: tl -> doit (n - 1) tl (hd :: acc) in
			doit n lst []

		let break p lst =
			let rec doit acc = function
				| [] -> (List.rev acc, [])
				| x :: xs as l ->
					if p x then (List.rev acc, l)
					else doit (x :: acc) xs in
			doit [] lst

		let split_n n lst =
			let rec doit n acc l =
				if n = 0 then (List.rev acc, l)
				else
					match l with
					| [] -> assert false
					| hd :: tl -> doit (n - 1) (hd :: acc) tl in
			doit n [] lst

	end${0}
snippet binheap
abbr binary heap
	module MakeBinaryHeap (M : sig type t val compare : t -> t -> int end) = struct

		type t = { node : M.t array; mutable size : int }

		let make n (init : M.t) = { node = Array.make n init; size = 0 }

		let empty_p t = if t.size = 0 then true else false

		let pop t =
			if t.size <= 0 then failwith "out of size" else
			let rec max_heapify i =
				let l = 2*i in
				let r = 2*i + 1 in
				let m = if l <= t.size && M.compare t.node.(l) t.node.(i) > 0 then l else i in
				let m = if r <= t.size && M.compare t.node.(r) t.node.(m) > 0 then r else m in
				if m = i then ()
				else begin
					let tmp = t.node.(i) in
					t.node.(i) <- t.node.(m);
					t.node.(m) <- tmp;
					max_heapify m
				end in
			let ret = t.node.(1) in
			t.node.(1) <- t.node.(t.size);
			t.size <- t.size - 1;
			max_heapify 1;
			ret

		let push x t =
			let parent i = int_of_float (floor (float_of_int i) /. 2.) in
			let rec doit i =
				let p = parent i in
				if i <= 1 || M.compare t.node.(p) t.node.(i) >= 0 then ()
				else begin
					let tmp = t.node.(i) in
					t.node.(i) <- t.node.(p);
					t.node.(p) <- tmp;
					doit p
				end in
			t.size <- t.size + 1;
			t.node.(t.size) <- x;
			doit t.size

	end

	module H = MakeBinaryHeap(struct type t = int let compare x y = x - y end)${0}
